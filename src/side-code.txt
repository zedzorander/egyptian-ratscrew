// crate to create server
//use std::net::{TcpListener, TcpStream};

// for use in main function
// let listener = TcpListener::bind().unwrap();

// try to display Rank enum
/*
impl std::fmt::Display for Rank {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let printable = match *self {
            Rank::Num(u32) => Rank::Num(u32).to_string(),
            Rank::Jack => "Jack".to_string(),
            Rank::Queen => "Queen".to_string(),
            Rank::King => "King".to_string(),
            Rank::Ace => "Ace".to_string(),
        };
        write!(f, "{}", printable)
    }
}
*/

// Handles data sent from clients
fn handle_client(stream::TcpStream) {

}
*/

// unimplemented function calls
    /*
    if is_sixty_nine(&pile) {
        println!("There is a sixty-nine");
        for i in &pile {
            println!("{}", i);
        }
    }
    else {
        println!("There is NO sixty-nine");
        for i in &pile {
            println!("{}", i);
        }
    }
    */

    /*for stream in listener.incoming() {
        handle_client(stream?);
    }*/

// Trying to implement order on first three elements of pile
//use std::iter::FromIterator;
//use std::cmp::Ordering;

/*
impl Ord for Rank {
    fn cmp(&self, other: &Rank) -> Ordering {
        self.cmp(&other)
    }
}

impl PartialOrd for Rank {
    fn partial_cmp(&self, other: &Rank) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Rank {
    fn eq(&self, other: &Rank) -> bool {
        self == other
    }
}
*/

/*
impl Ord for Card {
    fn cmp(&self, other: &Card) -> Ordering {
        self.rank.cmp(&other.rank)
    }
}

impl PartialOrd for Card {
    fn partial_cmp(&self, other: &Card) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
*/


