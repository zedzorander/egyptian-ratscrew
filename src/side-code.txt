// crate to create server
//use std::net::{TcpListener, TcpStream};

// for use in main function
// let listener = TcpListener::bind().unwrap();

// try to display Rank enum
/*
impl std::fmt::Display for Rank {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let printable = match *self {
            Rank::Num(u32) => Rank::Num(u32).to_string(),
            Rank::Jack => "Jack".to_string(),
            Rank::Queen => "Queen".to_string(),
            Rank::King => "King".to_string(),
            Rank::Ace => "Ace".to_string(),
        };
        write!(f, "{}", printable)
    }
}
*/

// attempt at shortening make_deck() (unsuccessful so far)
	/*
	let deck: Vec<Card> = vec![];

    for i in 2..11 {
        deck.push(Card::new(Rank::(i as i32), Suit::Hearts));
    }
    deck.push(Card::new(Rank::Jack, Suit::Hearts));
    deck.push(Card::new(Rank::Queen, Suit::Hearts));
    deck.push(Card::new(Rank::King, Suit::Hearts));
    deck.push(Card::new(Rank::Ace, Suit::Hearts));

    for i in 2..11 {
        deck.push(Card::new(Rank::(i as i32), Suit::Diamonds));
    }
    deck.push(Card::new(Rank::Jack, Suit::Diamonds));
    deck.push(Card::new(Rank::Queen, Suit::Diamonds));
    deck.push(Card::new(Rank::King, Suit::Diamonds));
    deck.push(Card::new(Rank::Ace, Suit::Diamonds));
        
    for i in 2..11 {
        deck.push(Card::new(Rank::(i as i32), Suit::Clubs));
    }
    deck.push(Card::new(Rank::Jack, Suit::Clubs));
    deck.push(Card::new(Rank::Queen, Suit::Clubs));
    deck.push(Card::new(Rank::King, Suit::Clubs));
    deck.push(Card::new(Rank::Ace, Suit::Clubs));
        
    for i in 2..11 {
        deck.push(Card::new(Rank::(i as i32), Suit::Spades));
    }
    deck.push(Card::new(Rank::Jack, Suit::Spades));
    deck.push(Card::new(Rank::Queen, Suit::Spades));
    deck.push(Card::new(Rank::King, Suit::Spades));
    deck.push(Card::new(Rank::Ace, Suit::Spades));
    
    deck   
    */

// unimplemented functions
/*
/// Checks if left and right cards form (6, 9) pairing
fn is_sixty_nine_match(left: &[Card], right: &[Card]) -> bool {
    if (&left[0..1]).eq(&[Card::new(Rank::Num(6), Suit::Clubs)]) && (&right[0..1]).eq(&[Card::new(Rank::Num(9), Suit::Clubs)]) {
        return true;
    }
    false
}

/// Top card and second card have ranks of 6 && 9 or 9 && 6
fn is_sixty_nine(pile: &Vec<Card>) -> bool {
    let (left, right) = pile.split_at(1);
    if is_sixty_nine_match(&left[0..1], &right[0..1]) {
        return true;
    }
    else if is_sixty_nine_match(&right[0..1], &right[0..1]) {
        return true;
    }
    false
}
*/
/*
/// Top card and third card have ranks 6 && 9 or 9 && 6
fn is_sixty_nine_sandwich(pile: Vec<Card>) -> bool {

}

// Handles data sent from clients
fn handle_client(stream::TcpStream) {

}
*/

// unimplemented function calls
    /*
    if is_sixty_nine(&pile) {
        println!("There is a sixty-nine");
        for i in &pile {
            println!("{}", i);
        }
    }
    else {
        println!("There is NO sixty-nine");
        for i in &pile {
            println!("{}", i);
        }
    }
    */

    /*for stream in listener.incoming() {
        handle_client(stream?);
    }*/

